using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.UI;

public class PlayerControls : MonoBehaviour
{
    [SerializeField] private InputReader _input;
    [SerializeField] private GameObject _gameManager;

    [SerializeField] private GameObject player;
    [SerializeField] private Rigidbody rb;
    [SerializeField] private float speed;
    [SerializeField] private float sprintMultiplyer;
    [SerializeField] private float jumpHeight;

    private Vector2 moveDirection;
    private Vector2 lookDirection;
    public bool isSprinting;

    public float sensitivity;
    public GameObject head;

    private void Start()
    {
        _input.MoveEvent += HandleMove;
        _input.JumpEvent += HandleJump;
        _input.LookEvent += HandleLook;
        _input.SprintStartEvent += StartSprint;
        _input.SprintEndEvent -= EndSprint;

        rb.GetComponent<Rigidbody>();
    }

    private void Update()
    {
        Move();
        Look();
    }

    private void HandleMove(Vector2 dir)
    {
        moveDirection = dir;
    }

    private void HandleLook(Vector2 dir)
    {
        lookDirection = dir;
    }

    private void HandleJump()
    {
        Jump();
    }

    // This Section of code was generated by ChatGPT
    #region Movement
    private void Move()
    {
        if (moveDirection == Vector2.zero)
        {
            return;
        }

        // Get the forward vector of the player's transform
        Vector3 forward = player.transform.forward;

        // Calculate the movement direction based on the forward vector and input direction
        Vector3 movement = forward * moveDirection.y + player.transform.right * moveDirection.x;

        // Normalize the movement vector to ensure consistent movement speed diagonally
        movement.Normalize();

        // Apply the movement to the player's position
        if (isSprinting)
        {
            transform.position += movement * ((speed * sprintMultiplyer) * Time.deltaTime);
        }
        else
        {
            transform.position += movement * (speed * Time.deltaTime);
        }
    }

    private void StartSprint()
    {
        isSprinting = true;
        Debug.Log("start sprint");
    }

    private void EndSprint()
    {
        isSprinting = false;
        Debug.Log("end sprint");
    }

    private void Look()
    {
        // Calculate the target rotation based on the current player rotation and input direction
        float targetRotationX = player.transform.rotation.eulerAngles.y + lookDirection.x * sensitivity * Time.deltaTime;

        // Apply the rotation to the player
        player.transform.rotation = Quaternion.Euler(0f, targetRotationX, 0f);

        // Ensure target rotation is between 0 and 360
        targetRotationX = Mathf.Repeat(targetRotationX, 360f);


        float targetRotationY = head.transform.rotation.eulerAngles.x - lookDirection.y * sensitivity * Time.deltaTime;
        head.transform.rotation = Quaternion.Euler(targetRotationY, targetRotationX, 0f);
    }

    // Set Grounded
    private int groundContact;
    public bool IsGrounded { get { return groundContact > 0; } }
    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.GetComponent<ObjectType>() != null && collision.gameObject.GetComponent<ObjectType>().isGround)
        {
            groundContact++;
        }
    }
    private void OnCollisionExit(Collision collision)
    {
        if (collision.gameObject.GetComponent<ObjectType>() != null && collision.gameObject.GetComponent<ObjectType>().isGround)
        {
            groundContact--;
        }
    }

    // Jump Function
    private void Jump()
    {
        if(IsGrounded)
        {
            rb.AddForce(new Vector3(0, jumpHeight, 0), ForceMode.Impulse);
        }
    }
    #endregion Movement
}